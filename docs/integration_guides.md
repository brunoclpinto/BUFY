# Integration Guides (Swift, Kotlin, C#)

Budget Core exposes a C-compatible ABI (see `docs/ffi_spec.md`) so native clients can link against the shared library produced from the Rust crate. This guide provides platform-specific steps to compile, package, and consume the library from Apple, Android/JVM, and .NET applications.

## Common Build Steps

1. Ensure the `ffi` feature is enabled when building:
   ```sh
   cargo build --release --features ffi
   ```
2. Artifacts:
   - Shared library: `target/release/libbudget_core.{dylib|so|dll}`
   - C header (generated by `cbindgen`): `target/ffi/include/budget_core.h`
   - Version metadata: exported by `ffi_core_version()` and `ffi_version()`
3. Copy (or package) both the shared library and header into your platform-specific project. Re-run the build whenever the FFI changes so bindings stay in sync.

> **Tip** – Use `cargo test --features ffi` before publishing to validate error propagation and thread-safety.

## Swift (macOS, iOS, iPadOS)

1. **Create a Swift Package Module**
   - Add a new `Swift Package` (e.g., `BudgetCoreFFI`) that wraps the C header.
   - Inside `Package.swift`, declare a `systemLibrary` target referencing `budget_core.h`.
   - Example module map (`module.modulemap`):
     ```text
     module BudgetCoreFFI [system] {
       header "budget_core.h"
       link "budget_core"
       export *
     }
     ```
2. **Embed the Library**
   - Copy `libbudget_core.dylib` (macOS) or `libbudget_core.a` (iOS static build via `cargo lipo`) into the Xcode project.
   - Add a build phase to ensure the library ships within the application bundle (`Copy Files` → `Frameworks` or custom path).
3. **Swift Wrapper**
   - Expose ergonomic APIs by wrapping C functions using `@_cdecl` helpers. Map integer status codes to Swift `Result` types.
   - Handle strings via `String(cString:)` and remember to call `ffi_string_free`.
4. **Version Check**
   ```swift
   precondition(
     String(cString: ffi_version()) == "0.1.0",
     "Incompatible FFI version"
   )
   ```
5. **Testing**
   - Use XCTest to create a ledger, snapshot JSON, and ensure persistence via `ffi_ledger_save`.

## Kotlin (Android/JVM)

1. **Compile for Android ABIs**
   ```sh
   cargo ndk -t armeabi-v7a -t arm64-v8a -t x86_64 \
     --features ffi --release
   ```
   This produces `.so` files under `target/<triple>/release/`.
2. **Package as AAR**
   - Create a Gradle module (e.g., `budgetcore`) with `jniLibs/abi/` folders containing the `.so` artifacts.
   - Add the generated header to `src/main/cpp/include/`.
3. **JNA/JNI Layer**
   - Implement thin JNI wrappers that forward calls to the exported functions. Consider using `Kotlinx.cinterop` for multiplatform projects.
   - Convert JSON payloads to Kotlin data classes using kotlinx.serialization.
4. **Version Enforcement**
   ```kotlin
   require(ffiVersion() == "0.1.0") { "Budget Core FFI mismatch" }
   ```
5. **Threading**
   - Wrap handles in Kotlin `Closeable` and call `ffi_ledger_free` from `close()` (use `use {}` blocks to ensure deterministic cleanup).

## C# (.NET, Windows/Linux)

1. **Build the DLL**
   ```sh
   cargo build --release --features ffi --target x86_64-pc-windows-msvc
   ```
   For Linux, produce `libbudget_core.so` and rename to `budget_core.dll` if consuming via `DllImport`.
2. **P/Invoke Declarations**
   ```csharp
   internal static class Native {
       [DllImport("budget_core", CallingConvention = CallingConvention.Cdecl)]
       internal static extern IntPtr ffi_core_version();
       // ... add wrappers for ledger create/save/etc.
   }
   ```
   - Use `SafeHandle` subclasses to release ledger handles automatically (`ReleaseHandle` → `ffi_ledger_free`).
   - Marshal strings with `Marshal.PtrToStringUTF8` and call `ffi_string_free`.
3. **Packaging**
   - Include the native DLL in the project output (`Copy to Output Directory: Always`). For self-contained deployments, use `RuntimeIdentifier`-specific folders (`runtimes/win-x64/native/`).
4. **Error Handling**
   - Create helper methods that check the returned status and, when non-zero, invoke `ffi_last_error_category`/`ffi_last_error_message` to throw descriptive managed exceptions.
5. **Testing**
   - Add xUnit/NUnit tests that load the library, create a ledger, save and reload from a temporary path, and assert that JSON snapshots contain expected data.

## Continuous Integration Tips

- Automate artifact generation in CI (`cargo build --release --features ffi` for each target).
- Publish shared libraries and headers to a predictable directory (`target/dist/ffi/<platform>`).
- Regenerate bindings whenever the FFI header changes to prevent drift.
- Record `ffi_version` in release notes so downstream apps can enforce compatibility.

For API specifics (functions, enums, error codes) consult `docs/ffi_spec.md`. Schema and domain design details live in `docs/design_overview.md`, while accessibility considerations are covered in `docs/localization_and_accessibility.md`.
